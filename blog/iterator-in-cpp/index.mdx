---
title: "Iterator in C++"
created: 2023-06-22
updated: 2023-06-22
author: "Richard Nguyen"
categories:
  - Sharing
tags:
  - C++
  - Python
published: true
thumbnail: ./iterator-in-cpp.png
---

The first time you learn about the [C++ Standard Template Library (STL)](https://cplusplus.com/reference/stl/), you probably get confused by the term **Iterator**. STL uses iterators for almost operations. It provides access to the elements in the underlying container. But why can you not access the elements directly? What does it do?

{/* Except */}

# Introduction

In the [Gang of Four (GOF) book](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8) on Design Pattern, it says:

> The intent of an iterator is to provide a way to access the elements of an
> aggregate object sequentially without exposing its underlying representation.
>
> [First edition - Page 353]

C++ STL defines it [as](https://cplusplus.com/reference/iterator/):

> An iterator is any object that, pointing to some element in a range of elements
> (such as an array or a container), has the ability to iterate through the
> elements of that range using a set of operators (with at least the increment
> (++) and dereference (\*) operators).

Iterators are used to access elements sequentially without exposing the underlying implementation of the object.

Let's say you have a binary tree. To traverse a tree, you can use any traversal techique that is your favorite. The problem with these traversing is that you can only traverse through the whole tree. What if you want to access the values in the tree one by one?

Iterators can help you achieve that goal. Instead of traversing the whole tree, iterator will give its users a chance to go one-by-one, or _sequentially_. And of course, you can traverse through the whole tree by combining a loop and iterators.

# Basic requirements

Each programming language has its own requirements on what basic methods an iterator must have. They can be defined under different literature. For C++, it's mostly defined as [overloaded operators](https://en.cppreference.com/w/cpp/language/operators). For Python, it uses [Data Model](https://docs.python.org/3/reference/datamodel.html). For Java, iterators are inherited from the super [Interface Iterable](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html).

However there are certain functionalities that an iterator must support:

1. **Sequential iteration** &mdash; iterators can be incremented to move to the next element.
2. **Termination** &mdash; iterators should know whether there is any element left.
3. **Retrieval** &mdash; iterators should be able to return the value of the element.

As mentioned, C++ supports these functionalities by overloading operators. For (1), C++ overloads the two unary incrementing operators, `operator++()` and `operator++(int)`, to advance the iterator. For (2), C++ overloads the two comparison operators, `operator==()` and `operator!=()`, to support termination. Finally, you can dererference an iterator to retrieve some data with `operator*()` and `operator->()`.

From now on, I will only focus on the C++ implementation of iterators.

# Categories

C++ supports a variety of iterators, depending on the need, the nature of the container and the underlying data structure to support that container.

From the [basic requirements](#basic-requirements), C++ defines as the [Input Iterator](https://cplusplus.com/reference/iterator/InputIterator/). That is the most basic iterator, which defines the basic functionalities of other iterator categories.

From here, C++ has other iterator categories according to different containers.

## Forward Iterator

[Forward Iterator](https://cplusplus.com/reference/iterator/ForwardIterator/) has everything that an Input iterator has. Additionally, foward iterators can be used as _lvalue_, which means its value can be reassigned.

An example to illustrate this point is by using the container [`std::forward_list`](https://cplusplus.com/reference/forward_list/forward_list/). Forward list is a singly-linked list, which can be only iterated in a forwarding direction (from start to finish). That's the basic functionalities from the input iterator.

With forward iterators, it allows assigning new value to the element to which the iterator is pointing. This can be done by dereferencing an iterator via `operator*()`.

```cpp title="forward_list.cpp"
#include <forward_list>
#include <iostream>

int main(void) {
  std::forward_list<int> ist{1, 2, 3, 4, 5};

  for (auto curr = list.begin(); curr != list.end(); ++curr)
    std::cout << *curr << " ";
  std::cout << "\n";

  auto first = list.begin();
  auto second = ++first;

  *second = -2; // Assign new value

  for (auto curr = list.begin(); curr != list.end(); ++curr)
    std::cout << *curr << " ";
  std::cout << "\n";

  return 0;
}
```

```txt title="Output" showLineNumber="false" enableCopy="false"
1  2 3 4 5
1 -2 3 4 5
```

## Bidirectional iterator

[Bidirectional iterator](https://cplusplus.com/reference/iterator/BidirectionalIterator/) has everything that Forward Iterator supports. Additionally, it also supports decrementing operations, which means you can iterate from start to finish, and backward! As oppose to incrementing, which uses `operator++`, the decrementing can be done via two unary operations, `operator--()` and `operator--(int)`.

Let's continue to illustrate this by using the container [`std::list`](https://cplusplus.com/reference/list/list/). Unlike forward list, `std::list` is a doubly-linked list whose nodes have two pointers, one pointing to the next node and one pointing to the previous node. It can be iterated in a forwarding direction, just like forward iterator, and can be iterated backward too. And of course, bidirectional iterators also support reassignment.

```cpp title="list.cpp"
#include <algorithm>
#include <iostream>
#include <list>

int main(void) {
  std::list<int> list{1, 2, 3, 4, 5};
  auto print = [](const int &e) { std::cout << e << " "; };

  std::for_each(list.begin(), list.end(), print);
  std::cout << "\n";

  auto first = list.begin();
  auto second = ++first;

  *second = -2;

  // Decrementing
  auto it = list.end();
  while (it != list.begin())
  {
    --it;
    print(*it);
  }
  std::cout << "\n";

  return 0;
}
```

```txt title="Output" showLineNumber="false" enableCopy="false"
1 2 3  4 5
5 4 3 -2 1
```

Now, iterating backward is troublesome since `end()` does not reference to the last element, but to _one-past_ the last element. This accomodates the range `[first, last)`. In C++ STL, if a container supports bidirectional iterator, it guarantees to provide `rbegin()` and `rend()` (prefix _'r'_ standing for reverse).

You can replace the decrementing loop with `rbegin()` and `rend()`.

```cpp
std::for_each(list.begin(), list.end(), print);
std::cout << "\n";
```

## Random Access Iterator

The final iterator category with the most supported operations is the [Random Access Iterator](https://cplusplus.com/reference/iterator/RandomAccessIterator/). They can be used to access elements with an offset.

All the above iterators have one drawback when you look at the examples. If you want to advance an iterator to a certain position, you must repeat either `operator++()` or `operator--()` for incrementing and decrementing respectively. As a result, it also supports `operator[]` to directly access an element.

Random access iterators allow advancing iterators with an offset, which can be done by `operator+(int)` and `operator-(int)`.

You might wonder _"Why can I implement operator+(int) by repeating operator++() multiple times?"_. The answer is **yes**. However, it will takes a linear time, $O(N)$ to complete the operation. The bigger the offset is, the worse it gets.

With random access iterators, the operation only takes constant time, $O(1)$, regardless how big the offset is.

An example of a container supporting this category is [`std::deque`](https://en.cppreference.com/w/cpp/container/deque). A deque behaves like a vector, but it also supports operations at the front of the container with constant time too.

```cpp title="deque.cpp"
#include <algorithm>
#include <deque>
#include <iostream>

int main(void) {
  std::deque<int> deque{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  auto print = [](const int &e) { std::cout << e << " "; };

  std::for_each(deque.begin(), deque.end(), print);
  std::cout << "\n";

  for (size_t i = 0; i < deque.size(); i += 2)
    print(*(deque.begin() + i));
  std::cout << "\n";

  for (size_t i = 1; i < deque.size(); i += 2)
    print(*(deque.begin() + i));
  std::cout << "\n";

  // direct access
  deque[5] = -6;

  // advance by offset
  first += 3;
  *first = -4;
  first -= 3;
  *first = -1;

  std::for_each(deque.rbegin(), deque.rend(), print);
  std::cout << "\n";

  return 0;
}
```

```txt title="Output" showLineNumber="false" enableCopy="false"
1 2 3 4 5 6 7 8 9 10
1 3 5 7 9
2 4 6 8 10
10 9 8 7 -6 5 -4 3 2 -1
```

# Conclusion
