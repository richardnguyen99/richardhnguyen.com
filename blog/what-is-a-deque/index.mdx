---
title: "What is a deque?"
created: 2023-06-23
updated: 2023-06-23
author: "Richard Nguyen"
categories:
  - Sharing
tags:
  - C++
  - Python
thumbnail: ./what-is-deque.png
---

Many problems can be solved with arrays and their dynamic version. In Python, you can use the builtin [`list`](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists). In C++, you use [`vector`](https://cplusplus.com/reference/vector/). But the drawback is that these dynamic array is terrible at insertion and deletion at the front due to shifting. Deque is created to solve this problem!

{/* Except */}

# Introduction

Deque, or **doubly-ended queue**, is a data structure created to solve the critical problem that dynamic arrays have: working with the front element.

As a reminder, dynamic arrays are great at inserting and deleting the last element in the array, thanks to the size property: appending new elements will increase the size. Assume there is no reallocation happening, the time complexity of this operation is constant.

However, inserting or deleting an element at some arbitary position will take linear time, $O(N)$ where $N$ is the distance between the position on which the operation performs and the position of the last element. This means working with the first element always yields the worst runtime. (Psst. I have a post about about [this](/posts/what-is-a-vector-in-cpp))

This is where deque comes in to "save the world"!

# What deque can do

What deque proposes and tries to solve is support insertion and deletion at the front of a container. You might wonder: "Has linked list already solved this problem?". That is correct. Insertion/deleteion at the front can be done with linked lists.

However, the problem with linked lists is that accessing elements takes linear time. The beauty of a deque is that it also supports constant access time (random access), just like a vector can do.

With these useful traits, deque can be used as the underlying data structure for both stack (first-in last-out) and queue (first-in first out).

# Implementation

> This article will focus heavily on the implementation on [`std::deque<T>`](https://en.cppreference.com/w/cpp/container/deque), and a bit from [`collections.deque`](https://docs.python.org/3/library/collections.html#collections.deque).

A deque maintains an array of fix-sized arrays. This data structure is often referred as _a map_. Initially, the map has an arbitary initial number of slots. In C++, this initial number is 8. In Python, it does not have an initial size as the implementation uses a doubly-linked list.

Each element in this map points to a block of elements. These blocks often have a fixed number of elements. In Python, the block length is set to 64, which means each block will contain 64 elements of a type. In C++, the block length is determined in bytes, which is 512. For example, C++ integer type `int` is 4 bytes, then the block length will be `512 / 4 = 128` elements in total. The bigger the size of a type is, the shorter the block is.

If the size of a type exceeds 512, C++ deque allocates only one object of that type, which means there is one element in a block.

> Deque has a complicated implementation due to many functionalities, I will not cover all the details. As usual, if you're interested in how the actual implementation works, please see my [oversimplified version](#)

# Deque iterator

The core functionalities rely on the implementation of its iterator.

> An iterator is an interface on how you can access the underlying elements without knowing too much the internal implementation. More detail about C++ iterator [here](/posts/iterator-in-cpp/).

In C++, a deque iterator contains _4_ essential member fields:

1. `map_node`: Map pointer that points to a block.
2. `start`: Block pointer that points to the first element.
3. `finish`: Block pointer that points to the end of the block.
4. `curr`: Block pointer that points to the last element.

Each deque object contains two iterators. One is used to mark the first range and one is used to mark the second range in the deque. The first pointer will grow backward, which means appending new elements will decrease the start iterator. Meanwhile, the second pointer will grow forward, which means appending new elements will increase the finish iterator.

<div className="mt-8">

![Deque illustrator 1](./deque-illustration.png "Deque illustrator (1)")

</div>

If we re-arrange this illustration so that all blocks look continous:

<div className="mt-8">

![Deque illustrator 2](./deque-illustration-2.png "Deque illustrator (2)")

</div>

In the second illustration, you have a better picture how the appending to front and to back works. Appending to the back will use the `finish` iterator and increase its internal `_curr` so that the deque can grow to the right. Appending to the front will use the `start` iterator and decrease its internal `_curr` so the the deque can grow to the left.
