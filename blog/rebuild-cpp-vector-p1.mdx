---
title: "Rebuild C++ Vector: Part 1 - Introduction"
created: 2022-08-31
update: ""
author: "Richard Nguyen"
description: "Vector has been one of the most used data structures by C++ programmers. It's properly the first template class that everyone programming in C++ would touch. It provides extremely efficient accessing elements (just as arrays) and relatively efficient adding or removing elements at its end. But do you know it works under the hood?"
tags:
  - "c++"
  - "explanation"
featuredImage: ./thumbnails/rebuild-cpp-vector-p1.png
previewFeaturedImage: ./thumbnails/rebuild-cpp-vector-p1-preview.png
featuredImageAlt: "Vector Iterator"
articleUrl: /articles/rebuild-cpp-vector-p1
series: "Rebuild C++ Vector"
chapter: 1
chapterName: "Introduction"
nextChapter: 2
nextChapterName: "Iterator"
nextChapterUrl: /articles/rebuild-cpp-vector-p2
displayTOC: true
---

If you have used C++ for programming, either for learning purposes or for actual production work, you must have known of the most common template class, `vector`.

[`std::vector`](https://en.cppreference.com/w/cpp/container/vector) is a template class provided by the _C++ Standard Template Library_. It's categorized in [Sequence Containers](https://en.cppreference.com/w/cpp/container#Sequence_containers). The main purpose is to create a dynamic array that can grow and shrink size during runtime.

I've been using `vector` since I learned programming with C++. I have decided to step further and _rebuilt_ it without the heavy stuff while still kept the best of it.

<Alert title="Disclaimer" status="danger" icon="danger">
  <p>
    My attempt to rebuild <code>vector</code> is for learning purposes to
    understand what's going on behind it. It's not supposed to replace{" "}
    <code>vector</code> since <code>vector</code> is well-supported, thoroughly
    tested and driven by community. So if you want to use for your actual work,
    please refer to{" "}
    <a
      target="_blank"
      href="https://en.cppreference.com/w/cpp/container/vector">
      this link
    </a>{" "}
    for more details.
  </p>
</Alert>

# Prerequisites

This article tends to cover the basis of vector, so I will try to keep it simple and explain clearly along the way as much as I can. That being said, there are some concepts that are good to know beforehand:

- [Classes](https://cplusplus.com/doc/tutorial/classes/)
- [Templates](https://cplusplus.com/doc/oldtutorial/templates/)
- [Allocator](https://en.cppreference.com/w/cpp/memory/allocator)

# Introduction

Before diving into the implementation, I think it's good to know the story behind why vector was invented in the first place.

Back then, C programmers could only use arrays to store a sequence of elements. It has worked alright, even till today. Though, there are some problems with arrays:

- **No boundary checking** &mdash; When accessing an array outside of the boundaries, it's considered as an [undefined behavior](https://en.cppreference.com/w/cpp/language/ub). It may work just fine on one day but it may also crash on another day.
- **No dynamic size** &mdash; When creating an array, the size to contain elements must be known beforehand. It can lead to either lack of space or waste of space when allocating not enough or too much space accordingly.
- **Manual memory management** &mdash; If an array is wished to be allocated on the heap, programmers have to manually determine how many memory blocks to allocate and deallocate them when not using anymore.

The invention of vector is to remove those painful problems while still keep the best of array.

# Overview

A vector can be seen as an array with more safety and more functionalities. In fact, a vector is a wrapper around an internal array. It has data members to keep track of that array and, provides methods and functionalities to work around it. This design will still let us keep the best of an array:

- **Random access** &mdash; Sometimes it's called _direct access_. It allows to access any element in the array in constant time regardless how many elements are stored.
- **Pointer arithmetic** &mdash; ALong with random access, pointer arithmetic gives users a straightforward way to work with arrays like traversing, assignment and dereferencing.
- **Cache friendly** &mdash; Elements are stored in a contiguous sequence. This reduces memory access time because cache will load a large chunk of them on the first access so that future access will be performed on cache instead of memory.

# Design

Now we know what vector is. Let's get into how vector is implemented!

## Data members

The first thing is to figure out what data members we should have. As mentioned above, a vector uses an internal array to keep track of. So the data members should at least maintain:

- **_Capacity_** &mdash; Maximum number of elements can be stored.
- **_Size_** &mdash; Current number of elements are being stored.
- **_Location_** &mdash; The address of the internal array.

There are two major ways to maintain these information in C++.

```cpp title=vector.h
#include <memory> // std::allocator

// Approach 1
template <typename T>
class vector
{
private:
    T*                _data;
    unsigned int      _size;
    unsigned int      _capacity;
    std::allocator<T> _alloc;
};

// Approach 2
template <typename T>
class vector
{
private:
    T*                _start;    // Point to the first element
    T*                _finish;   // Point to one-past the last element
    T*                _end;      // Point to the end of the internal array
    std::allocator<T> _alloc;
};
```

Both ways are validated to maintain internal array for further usage. However, `std::vector` uses the second approach, so it will be the main approach used in the article.

<Summary summary="Why the second approach?">
  <p>
    (IMHO) Although both ways are validated, the second approach can reduce the
    code written to achieve the same thing comparatively to the first approach.
    For example, <code>vector</code> has many methods to work with the end of
    the array like <code>push_back()</code> and <code>pop_back()</code>. Instead
    of writing <code>_data + _size</code> to access the end of the current
    array, <code>_finish</code> will suffice.
  </p>
</Summary>

## Allocator

One more thing to note here is that all standard library containers, including vector, uses an extra template parameter that nobody usually cares about,[`std::allocator`](https://en.cppreference.com/w/cpp/memory/allocator). The full template declaration of `std::vector` looks like this:

```cpp title=std::vector
template<
    class T,
    class Allocator = std::allocator<T>
> class vector
{
  // ...
}
```

It's got a default argument, which is `std::allocator<T>`, that nobody really cares or they just pretends it doesn't exist because it could be a painful experience if you don't know what you're doing. For that matter, I will not be talking about it this article. However, to keep it stick to the original implementation of vector, I will be still using it as a uniform tool to allocate/deallocate memory and construct/destroy elements.

## Member types

Member types are a set of [`typedefs`](https://en.cppreference.com/w/cpp/language/typedef) that provides definitions of types used by vector. It attempts to abstract the detail of the types associated with vector and provides a uniform set of types amongst other containers.

Here are some common member types used in vector:

```cpp title=vector.h
template <typename T>
class vector
{
public:
    using value_type        = T;
    using allocator_type    = std::allocator<value_type>;
    using allocator_traits  = std::allocator_traits<allocator_type>;

    using pointer         = typename allocator_traits::pointer;
    using const_pointer   = typename allocator_traits::const_pointer;
    using size_type       = typename allocator_traits::size_type;
    using difference_type = typename allocator_traits::difference_type;

    using reference       = value_type&
    using const_reference = const value_type&;
    ...

private:
    allocator_type _alloc;
    pointer _start;
    pointer _finish;
    pointer _end;
    ...
};
```

The purpose of type aliasing to define member types like how STL defines in its containers (not just vector) is to support generic programming in which your algorithm can accept a vary of types. For example, if I had a function `sum()` to calculate the total sum of elements stored in a vector and return the result, I can do like this:

```cpp
template <typename T>
T sum(const std::vector<T>& cont)
{
    T result = 0;
    for (const T& e : cont)
      result += e;

    return result;
}
```

But there are other containers in STL that you can do exactly the same steps, [`deque`](https://en.cppreference.com/w/cpp/container/deque) for example:

```cpp
template <typename T>
T sum(const std::deque<T>& cont)
{
    T result = 0;
    for (const T& e : cont)
      result += e;

    return result;
}
```

They look indentical except for the type of the container parameter. Imagine you have to create many more versions of `sum()` for different containers. This is when generic programming comes to play. Instead of making the type of elements generic, we make the whole container type generic.

But hey, if you make the container type generic, how do we know what type of the underlying elements is? This is when the member types save you:

```cpp
template <typename Container>
typename Container::value_type
sum(const Container &cont)
{
    typename Container::value_type total = 0;
    for (typename Container::const_reference e : cont)
        total += e;

    return total;
}
```

With this version, you can use `sum()` on any container that supports iteration and its elements supports the addition and assignment operators. An example is:

```cpp
#include <deque>
#include <forward_list>
#include <iostream>
#include <vector>

template <typename Container>
typename Container::value_type
sum(const Container &cont)
{
    typename Container::value_type total = 0;
    for (typename Container::const_reference e : cont)
        total += e;

    return total;
}

int
main(int argc, const char **argv)
{
    std::vector<unsigned int> vector{1, 2, 3, 4, 5, 6, 7, 8};
    std::deque<double> deque{1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6};
    std::forward_list<int> list{-4, -3, -2, -1, 0, 1, 2, 3, 4};

    std::cout << "Sum of vector: " << sum(vector) << "\n";
    std::cout << "Sum of deque: " << sum(deque) << "\n";
    std::cout << "Sum of list: " << sum(list) << "\n";

    return 0;
}

// Output
// Sum of vector: 36
// Sum of deque: 9.1
// Sum of list: 0
```

<Alert title="typename & auto" status="primary" icon="info">
  <ul>
    <li>
      <code>typename</code> is a keyword to specify the identifier that follows
      after it is a type. Without <code>typename</code>,{" "}
      <code>Container::value_type</code>, for example, would be considered a
      static member.
    </li>
    <li>
      Sometimes explicit types can be too complex and hard to write, or
      something you just don't care what the type actually does, C++ has
      introduced a keyword called <code>auto</code> to save your day. For
      example, you can replace <code>typename Container::const_reference</code>{" "}
      with <code>const auto&</code>. <br />
      Basically, it's a placeholder for the actual type. The compiler will deduce
      the actual type for you instead. However, it can be overused and backfire.{" "}
      <a href="https://stackoverflow.com/questions/6434971/how-much-is-too-much-with-c11-auto-keyword">
        More details about this
      </a>.
    </li>
  </ul>
</Alert>

# Conclusion

At this point, we have set up all the basic requirements to build our own vector. There are still more complicated member types such as iterators to add. In fact, that will be the next concept to cover.

# References

- [CppCon 2017: Bob Steagall “How to Write a Custom Allocator”](https://www.youtube.com/watch?v=kSWfushlvB8)
- [CppReference std::vector](https://en.cppreference.com/w/cpp/container/vector)
- [CppReference std::allocator_traits](https://en.cppreference.com/w/cpp/memory/allocator_traits)
- [StackOverflow Discussion: How are member types implemented?](https://stackoverflow.com/questions/14037392/how-are-member-types-implemented)
- [StackOverflow Discussion: vector vs. list in STL](https://stackoverflow.com/questions/2209224/vector-vs-list-in-stl)
